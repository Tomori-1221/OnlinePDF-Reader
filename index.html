<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Online PDF Reader</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: none;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 1200px;
            margin: 20px;
            overflow: hidden;
            position: relative;
        }

        .header {
            background: #2264a7;
            color: white;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            text-align: center;
        }

        .upload-section {
            text-align: center;
            padding: 30px;
            border-bottom: 1px solid #eee;
        }

        .custom-upload {
            background: #6d6d6d;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .custom-upload:hover {
            background: #303030;
            transform: translateY(-2px);
        }

        #fileInput {
            display: none;
        }

        .content-viewer {
            padding: 30px;
            min-height: 600px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        .pdf-page {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin: 20px 0;
            max-width: 100%;
            display: block;
            position: relative;
        }

        .drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 10px;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .tool-btn {
            padding: 8px 12px;
            border: 1px solid #5d5f61;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .tool-btn.active {
            background: #5d5f61;
            color: white;
        }

        .color-picker {
            width: 30px;
            height: 30px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        .brush-size {
            width: 80px;
            height: 30px;
        }

        .zoom-controls {
            position: fixed;
            bottom: 40px;
            right: 40px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Online PDF Reader</h1>
        </div>

        <div class="toolbar">
            <button class="tool-btn active" data-tool="pen">âœ ç”»ç¬”</button>
            <button class="tool-btn" data-tool="eraser">ğŸ§¹ æ©¡çš®æ“¦</button>
            <button class="tool-btn" data-tool="scroll">â˜° æ»šåŠ¨</button>
            <input type="color" class="color-picker" value="#ff4444">
            <input type="range" class="brush-size" min="1" max="20" value="3">
            <button class="tool-btn" onclick="undo()">â†© æ’¤é”€</button>
            <button class="tool-btn" onclick="redo()">â†ª é‡åš</button>
        </div>

        <div class="upload-section">
            <button class="custom-upload" onclick="document.getElementById('fileInput').click()">
                ğŸ“ Upload a PDF-File
            </button>
            <input type="file" id="fileInput" accept="application/pdf">
        </div>

        <div class="status-message" id="status">è¯·é€‰æ‹©è¦æŸ¥çœ‹çš„PDFæ–‡ä»¶</div>
        
        <div class="content-viewer" id="content"></div>
        <div class="loading" id="loading">â³ åŠ è½½ä¸­...</div>
    </div>

    <div class="zoom-controls">
        <button class="tool-btn" onclick="adjustZoom(0.8)">âˆ’</button>
        <span id="zoom-level">100%</span>
        <button class="tool-btn" onclick="adjustZoom(1.2)">+</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        let currentScale = 1;
        let originalSizes = new Map();
        let isRendering = false;
        
        // ç»˜å›¾ç³»ç»Ÿå˜é‡
        let currentTool = 'pen';
        let isDrawing = false;
        let currentPath = null;
        let drawingHistory = [];
        let historyPointer = -1;
        let brushColor = '#ff4444';
        let brushSize = 3;
        let eraserSize = 10;
        let currentCanvas = null;

        // PDFæ¸²æŸ“åŠŸèƒ½
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            if(isRendering) return;
            isRendering = true;
            
            const file = e.target.files[0];
            if (!file) return;

            const loading = document.getElementById('loading');
            const viewer = document.getElementById('content');
            const status = document.getElementById('status');

            viewer.innerHTML = '';
            originalSizes.clear();
            drawingHistory = [];
            historyPointer = -1;
            status.textContent = 'Loading...';
            loading.style.display = 'block';

            try {
                const arrayBuffer = await readFileAsync(file);
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                status.textContent = `å·²åŠ è½½ Â· å…± ${pdf.numPages} é¡µ`;
                const baseWidth = viewer.clientWidth - 60;

                for(let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    await renderPage(pdf, pageNum, baseWidth);
                }

                currentScale = 1;
                updateZoomDisplay();
                setupDrawingHandlers();
            } catch(err) {
                status.textContent = 'é”™è¯¯: ' + err.message;
                console.error('PDFæ¸²æŸ“å¤±è´¥:', err);
            } finally {
                loading.style.display = 'none';
                isRendering = false;
            }
        });

        async function renderPage(pdf, pageNum, baseWidth) {
            const page = await pdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1 });
            const viewer = document.getElementById('content');
            
            const dpr = window.devicePixelRatio || 1;
            let scale = Math.min(2, (baseWidth / viewport.width) * 1.3);
            scale *= dpr;

            const scaledViewport = page.getViewport({ scale });
            
            // åˆ›å»ºPDFç”»å¸ƒ
            const pdfCanvas = document.createElement('canvas');
            const pdfCtx = pdfCanvas.getContext('2d');
            
            pdfCanvas.width = scaledViewport.width;
            pdfCanvas.height = scaledViewport.height;
            pdfCanvas.style.width = `${scaledViewport.width / dpr}px`;
            pdfCanvas.style.height = `${scaledViewport.height / dpr}px`;
            pdfCanvas.className = 'pdf-page';

            originalSizes.set(pdfCanvas, {
                width: scaledViewport.width / dpr,
                height: scaledViewport.height / dpr,
                ratio: viewport.width / viewport.height
            });

            // åˆ›å»ºç»˜å›¾å±‚
            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.className = 'drawing-layer';
            drawingCanvas.width = scaledViewport.width;
            drawingCanvas.height = scaledViewport.height;
            drawingCanvas.style.width = pdfCanvas.style.width;
            drawingCanvas.style.height = pdfCanvas.style.height;
            
            const wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.appendChild(pdfCanvas);
            wrapper.appendChild(drawingCanvas);
            
            viewer.appendChild(wrapper);

            // æ¸²æŸ“PDFå†…å®¹
            pdfCtx.imageSmoothingEnabled = true;
            pdfCtx.imageSmoothingQuality = 'high';
            await page.render({
                canvasContext: pdfCtx,
                viewport: scaledViewport,
                intent: 'display'
            }).promise;
        }

        // ç»˜å›¾åŠŸèƒ½å®ç°
        function setupDrawingHandlers() {
            document.querySelectorAll('.pdf-page').forEach(pdfCanvas => {
                const wrapper = pdfCanvas.parentNode;
                const drawingCanvas = wrapper.querySelector('.drawing-layer');
                const ctx = drawingCanvas.getContext('2d');
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = 'source-over';

                // é¼ æ ‡äº‹ä»¶
                wrapper.addEventListener('mousedown', startDrawing);
                wrapper.addEventListener('mousemove', draw);
                wrapper.addEventListener('mouseup', endDrawing);
                wrapper.addEventListener('mouseleave', endDrawing);

                // è§¦æ‘¸äº‹ä»¶
                wrapper.addEventListener('touchstart', touchStart);
                wrapper.addEventListener('touchmove', touchMove);
                wrapper.addEventListener('touchend', endDrawing);
            });
        }

        function getCanvasPosition(canvas, clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // ä¿®æ”¹æ©¡çš®æ“¦é€»è¾‘
        function startDrawing(e) {
            const drawingCanvas = e.currentTarget.querySelector('.drawing-layer');
            const pos = getCanvasPosition(drawingCanvas, 
                e.clientX || e.touches[0].clientX, 
                e.clientY || e.touches[0].clientY
            );
            
            isDrawing = true;
            currentCanvas = drawingCanvas;

            if (currentTool === 'eraser') {
                // å¦‚æœæ˜¯æ©¡çš®æ“¦ï¼ŒæŸ¥æ‰¾å¹¶åˆ é™¤åŒ…å«å½“å‰ä½ç½®çš„è·¯å¾„
                const ctx = drawingCanvas.getContext('2d');
                const pathsToRemove = [];
                drawingHistory.forEach((record, index) => {
                    if (record.canvas === drawingCanvas && isPointInPath(record.path, pos)) {
                        pathsToRemove.push(index);
                    }
                });

                // åˆ é™¤è·¯å¾„å¹¶é‡ç»˜
                pathsToRemove.reverse().forEach(index => drawingHistory.splice(index, 1));
                redrawAllCanvases();
                isDrawing = false; // æ©¡çš®æ“¦ä¸éœ€è¦æŒç»­ç»˜åˆ¶
                return;
            }

            // æ™®é€šç»˜å›¾é€»è¾‘
            currentPath = {
                tool: currentTool,
                color: brushColor,
                size: brushSize,
                points: [pos]
            };

            const ctx = drawingCanvas.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.strokeStyle = brushColor;
            ctx.lineWidth = brushSize;
            ctx.globalCompositeOperation = 'source-over';
        }

        function isPointInPath(path, point) {
            // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨è·¯å¾„èŒƒå›´å†…
            const threshold = path.size * 2; // å…è®¸çš„è¯¯å·®èŒƒå›´
            for (let i = 0; i < path.points.length; i++) {
                const p = path.points[i];
                const distance = Math.sqrt((p.x - point.x) ** 2 + (p.y - point.y) ** 2);
                if (distance <= threshold) {
                    return true;
                }
            }
            return false;
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const drawingCanvas = currentCanvas;
            const pos = getCanvasPosition(drawingCanvas, 
                e.clientX || e.touches[0].clientX, 
                e.clientY || e.touches[0].clientY
            );
            
            const ctx = drawingCanvas.getContext('2d');
            currentPath.points.push(pos);
            
            // è´å¡å°”æ›²çº¿å¹³æ»‘å¤„ç†
            if(currentPath.points.length > 2) {
                const controlPoint = currentPath.points[currentPath.points.length-2];
                ctx.quadraticCurveTo(
                    controlPoint.x, controlPoint.y,
                    pos.x, pos.y
                );
            } else {
                ctx.lineTo(pos.x, pos.y);
            }
            
            ctx.stroke();
        }

        function endDrawing() {
            if (!isDrawing) return;
            
            isDrawing = false;
            
            // ä¿å­˜å†å²è®°å½•
            drawingHistory = drawingHistory.slice(0, historyPointer + 1);
            drawingHistory.push({
                canvas: currentCanvas,
                path: currentPath
            });
            historyPointer++;
            
            currentPath = null;
            currentCanvas = null;
        }

        // æ’¤é”€/é‡åšåŠŸèƒ½
        function undo() {
            if(historyPointer < 0) return;
            
            historyPointer--;
            redrawAllCanvases();
        }

        function redo() {
            if(historyPointer >= drawingHistory.length - 1) return;
            
            historyPointer++;
            redrawAllCanvases();
        }

        function redrawAllCanvases() {
            document.querySelectorAll('.drawing-layer').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawingHistory.slice(0, historyPointer + 1).forEach(record => {
                    if(record.canvas === canvas) {
                        drawPath(ctx, record.path);
                    }
                });
            });
        }

        function drawPath(ctx, path) {
            ctx.beginPath();
            ctx.globalCompositeOperation = path.tool === 'eraser' 
                ? 'destination-out' 
                : 'source-over';
            
            ctx.strokeStyle = path.color;
            ctx.lineWidth = path.size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            path.points.forEach((point, index) => {
                if(index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else if(index > 1) {
                    const prevPoint = path.points[index-1];
                    ctx.quadraticCurveTo(
                        prevPoint.x, prevPoint.y,
                        point.x, point.y
                    );
                }
            });
            ctx.stroke();
        }

        // å·¥å…·åˆ‡æ¢
        document.querySelectorAll('[data-tool]').forEach(btn => {
            btn.addEventListener('click', function() {
                currentTool = this.dataset.tool;
                document.querySelectorAll('[data-tool]').forEach(b => 
                    b.classList.remove('active')
                );
                this.classList.add('active');

                // å¦‚æœæ˜¯æ»šåŠ¨æ¨¡å¼ï¼Œç¦ç”¨ç»˜å›¾äº‹ä»¶
                if (currentTool === 'scroll') {
                    document.querySelectorAll('.pdf-page').forEach(canvas => {
                        const wrapper = canvas.parentNode;
                        wrapper.style.pointerEvents = 'auto'; // å¯ç”¨æ»šåŠ¨
                    });
                    document.querySelectorAll('.drawing-layer').forEach(layer => {
                        layer.style.pointerEvents = 'none'; // ç¦ç”¨ç»˜å›¾
                    });
                } else {
                    document.querySelectorAll('.pdf-page').forEach(canvas => {
                        const wrapper = canvas.parentNode;
                        wrapper.style.pointerEvents = 'none'; // ç¦ç”¨æ»šåŠ¨
                    });
                    document.querySelectorAll('.drawing-layer').forEach(layer => {
                        layer.style.pointerEvents = 'auto'; // å¯ç”¨ç»˜å›¾
                    });
                }
            });
        });

        // é¢œè‰²å’Œå°ºå¯¸é€‰æ‹©
        document.querySelector('.color-picker').addEventListener('input', function(e) {
            brushColor = e.target.value;
        });

        document.querySelector('.brush-size').addEventListener('input', function(e) {
            brushSize = parseInt(e.target.value);
        });

        // ç¼©æ”¾åŠŸèƒ½
        function adjustZoom(factor) {
            currentScale = Math.max(0.5, Math.min(currentScale * factor, 3));
            document.querySelectorAll('.pdf-page').forEach(canvas => {
                const original = originalSizes.get(canvas);
                if(original) {
                    canvas.style.width = `${original.width * currentScale}px`;
                    canvas.style.height = `${original.height * currentScale}px`;
                }
            });
            document.querySelectorAll('.drawing-layer').forEach(layer => {
                layer.style.width = layer.previousElementSibling.style.width;
                layer.style.height = layer.previousElementSibling.style.height;
            });
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-level').textContent = `${Math.round(currentScale * 100)}%`;
        }

        // è¾…åŠ©å‡½æ•°
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        function touchStart(e) {
            e.preventDefault();
            startDrawing(e);
        }

        function touchMove(e) {
            e.preventDefault();
            draw(e);
        }

        // ä¿å­˜PDFåŠŸèƒ½
        async function savePDF() {
            const pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array() }).promise;
            const pdfPages = document.querySelectorAll('.pdf-page');
            const pdfAnnotations = document.querySelectorAll('.drawing-layer');

            const pdfCanvas = document.createElement('canvas');
            const pdfCtx = pdfCanvas.getContext('2d');

            const pdfWriter = new PDFLib.PDFDocument();

            for (let i = 0; i < pdfPages.length; i++) {
                const pageCanvas = pdfPages[i];
                const annotationCanvas = pdfAnnotations[i];

                // åˆå¹¶PDFé¡µé¢å’Œæ‰¹æ³¨
                pdfCanvas.width = pageCanvas.width;
                pdfCanvas.height = pageCanvas.height;
                pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                pdfCtx.drawImage(pageCanvas, 0, 0);
                pdfCtx.drawImage(annotationCanvas, 0, 0);

                const pdfImage = pdfCanvas.toDataURL('image/png');
                const pdfPage = await pdfWriter.addPage([pageCanvas.width, pageCanvas.height]);
                const pdfImageEmbed = await pdfWriter.embedPng(pdfImage);
                pdfPage.drawImage(pdfImageEmbed, {
                    x: 0,
                    y: 0,
                    width: pageCanvas.width,
                    height: pageCanvas.height,
                });
            }

            const pdfBytes = await pdfWriter.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'annotated.pdf';
            link.click();
        }

        // æ‹–æ‹½ä¸Šä¼ 
        document.addEventListener('dragover', e => e.preventDefault());
        document.addEventListener('drop', e => {
            e.preventDefault();
            if(e.dataTransfer.files.length) {
                document.getElementById('fileInput').files = e.dataTransfer.files;
                document.getElementById('fileInput').dispatchEvent(new Event('change'));
            }
        });
    </script>
</body>
</html>